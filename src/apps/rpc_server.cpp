/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "../common/rpc.h"
#include "rpc_resource.hpp"
#include "rpc_resource_manager.hpp"
#include "unistd.h"

#define ASSERT_RETV(a, b) \
    if (NULL == a)        \
        return b;
static guint32 rpc_verify_user_check(const RPCInput *argp, const RPCOutput *output);
static guint32 rpc_user_identify(const guint usermode,
                                 const int userid,
                                 const guchar *username,
                                 const guchar *userip);
RPCOutput *all_api_in_one_1_svc(RPCInput *argp, struct svc_req *rqstp)
{
    static RPCOutput output_para;
    printf("%s, at server.\n", __func__);
    /* printf("%s: arrive at rpc server\n", __FUNCTION__); */
    /* sleep(3 * 60); */
    /* printf("%s: arrive at rpc server after 3 min\n", __FUNCTION__); */
    guint32 ulret            = 0;
    guchar *pszout           = NULL;
    rpc_call_smm rpc_funcall = NULL;
    guchar err               = 0xff;
    if (NULL == argp)
    {
        printf("%s, input para null point\n", __func__);
        goto FAILED_RET;
    }
    if ((strnlen((gchar *)argp->username, sizeof(argp->username)) >= sizeof(argp->username)) ||
        (strnlen((gchar *)argp->userIP, sizeof(argp->userIP)) >= sizeof(argp->userIP)))
    {
        printf("%s,  invalid para.\n", __func__);
        goto FAILED_RET;
    }
    if (0 != argp->out_para_len)
    {
        if (argp->out_para_len > MAX_SIZE_RPC_MEM)
        {
            printf("%s, malloc large(0x%x).\n", __func__, argp->out_para_len);
            goto FAILED_RET;
        }
        if (NULL == (pszout = (guchar *)malloc(argp->out_para_len)))
        {
            printf("%s, malloc large(0x%x).\n", __func__, argp->out_para_len);
            goto FAILED_RET;
        }
        memset(pszout, 0, (guint)argp->out_para_len);
    }
    output_para.output_para.output_para_len = argp->out_para_len;
    output_para.output_para.output_para_val = pszout;
    if (VOS_ERR == rpc_verify_user_check(argp, &output_para))
    {
        printf("%s, check user ok\n", __func__);
        if ((NULL != pszout) && sizeof(gchar) == output_para.output_para.output_para_len)
        {
            free(pszout);
            pszout = NULL;
        }
        if ((NULL == output_para.output_para.output_para_val) ||
            (0 == output_para.output_para.output_para_len))
        {
            goto FAILED_RET;
        }
        return &output_para;
    }
    rpc_funcall = RpcresGetRpcFunc(argp->fun_index);
    if (rpc_funcall != NULL)
    {
        ulret = rpc_funcall(argp->username, argp->userIP, argp->usermode,
                            argp->input_para.input_para_val, argp->input_para.input_para_len,
                            pszout, argp->out_para_len);
        if (ulret != 0)
        {
            printf("%s, APIfunc failed fundex:%d ret:0x%x.\n", __func__, argp->fun_index, ulret);
            goto FAILED_RET;
        }
        output_para.output_para.output_para_len = argp->out_para_len;
        output_para.output_para.output_para_val = pszout;
        return &output_para;
    }
    else
    {
        printf("%s, APIfunc not exit fundex:%d\n", __func__, argp->fun_index);
        goto FAILED_RET;
    }
FAILED_RET:
    output_para.output_para.output_para_len = sizeof(guchar);
    output_para.output_para.output_para_val = &err;
    if (NULL != pszout)
    {
        free(pszout);
        pszout = NULL;
    }
    return &output_para;
}
static guint32 rpc_verify_user_check(const RPCInput *argp, const RPCOutput *output)
{

    guint32 ulret = 0;
    ASSERT_RETV(output, FALSE);
    ASSERT_RETV(argp, FALSE);
    ulret = rpc_user_identify(argp->usermode, argp->userid, argp->username, argp->userIP);
    if (VOS_OK != ulret)
    {
        printf("%s, all_api_in_one_1_svc::rpc identify failed.", __FUNCTION__);
        return VOS_ERR;
    }

    return ulret;
}

static guint32 rpc_user_identify(const guint usermode,
                                 const int userid,
                                 const guchar *username,
                                 const guchar *userip)
{
    return 0;
}

RPCIDOutput *rpc_identify_remote_1_svc(RPCIDInput *argp, struct svc_req *rqstp)
{
    static RPCIDOutput result;
    printf("%s: arrive at rpc server\n", __FUNCTION__);

    /*
     * insert server code here
     */

    return (&result);
}
